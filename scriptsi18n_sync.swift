#!/usr/bin/env swift

//
//  Copyright RevenueCat Inc. All Rights Reserved.
//
//  Licensed under the MIT License (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      https://opensource.org/licenses/MIT
//
//  i18n_sync.swift
//
//  Auto-translation pipeline for new i18n keys
//  Detects missing translations and generates them
//
//  Usage:
//    swift scripts/i18n_sync.swift --check   # CI mode: fail if out of sync
//    swift scripts/i18n_sync.swift --sync    # Dev mode: generate translations
//

import Foundation

// MARK: - Configuration

struct SyncConfig {
    static let resourcesPath = "Resources"
    static let supportedLocales = ["en", "tr"]
    static let baseLocale = "en"
    
    // Translation mappings for common terms
    static let commonTranslations: [String: [String: String]] = [
        "OK": ["tr": "Tamam"],
        "Cancel": ["tr": "ƒ∞ptal"],
        "Done": ["tr": "Tamam"],
        "Save": ["tr": "Kaydet"],
        "Delete": ["tr": "Sil"],
        "Edit": ["tr": "D√ºzenle"],
        "Close": ["tr": "Kapat"],
        "Back": ["tr": "Geri"],
        "Next": ["tr": "ƒ∞leri"],
        "Continue": ["tr": "Devam"],
        "Confirm": ["tr": "Onayla"],
        "Yes": ["tr": "Evet"],
        "No": ["tr": "Hayƒ±r"],
        "All subscriptions": ["tr": "T√ºm abonelikler"],
        "Restore purchases": ["tr": "Satƒ±n alƒ±mlarƒ± geri y√ºkle"],
        "Restore": ["tr": "Geri y√ºkle"],
        "Purchases restored successfully!": ["tr": "Satƒ±n alƒ±mlar ba≈üarƒ±yla geri y√ºklendi!"],
        "Terms and conditions": ["tr": "≈ûartlar ve ko≈üullar"],
        "Terms": ["tr": "≈ûartlar"],
        "Privacy policy": ["tr": "Gizlilik politikasƒ±"],
        "Privacy": ["tr": "Gizlilik"],
        "Annual": ["tr": "Yƒ±llƒ±k"],
        "Monthly": ["tr": "Aylƒ±k"],
        "Weekly": ["tr": "Haftalƒ±k"],
        "Lifetime": ["tr": "√ñm√ºr boyu"]
    ]
}

// MARK: - Main Pipeline

final class I18nSync {
    enum Mode {
        case check  // Fail if out of sync (CI)
        case sync   // Generate missing translations (Dev)
    }
    
    private let mode: Mode
    private var modifications: [String: [Translation]] = [:]
    private var errors: [String] = []
    
    struct Translation {
        let key: String
        let value: String
        let isAutoGenerated: Bool
    }
    
    init(mode: Mode) {
        self.mode = mode
    }
    
    func run() -> Int32 {
        print("üåç i18n Sync Pipeline")
        print("Mode: \(mode == .check ? "CHECK (CI)" : "SYNC (Dev)")\n")
        
        guard let baseStrings = loadStrings(locale: SyncConfig.baseLocale) else {
            print("‚ùå Failed to load base locale (\(SyncConfig.baseLocale))")
            return 1
        }
        
        for locale in SyncConfig.supportedLocales where locale != SyncConfig.baseLocale {
            syncLocale(locale, baseStrings: baseStrings)
        }
        
        return finalize()
    }
    
    // MARK: - Sync Logic
    
    private func syncLocale(_ locale: String, baseStrings: [String: String]) {
        print("üìù Processing \(locale)...")
        
        guard let currentStrings = loadStrings(locale: locale) else {
            errors.append("Failed to load \(locale) strings")
            return
        }
        
        var updatedStrings = currentStrings
        var newTranslations: [Translation] = []
        
        for (key, baseValue) in baseStrings {
            if currentStrings[key] == nil {
                // Missing translation - auto-generate
                let translatedValue = translate(baseValue, from: SyncConfig.baseLocale, to: locale)
                updatedStrings[key] = translatedValue
                
                newTranslations.append(Translation(
                    key: key,
                    value: translatedValue,
                    isAutoGenerated: true
                ))
                
                print("  + \(key): \(translatedValue) [AUTO]")
            }
        }
        
        if !newTranslations.isEmpty {
            modifications[locale] = newTranslations
            
            if mode == .sync {
                writeStrings(locale: locale, strings: updatedStrings)
            }
        }
    }
    
    // MARK: - Translation Engine
    
    private func translate(_ text: String, from: String, to: String) -> String {
        // First check common translations
        if let common = SyncConfig.commonTranslations[text]?[to] {
            return common
        }
        
        // Handle format strings - preserve placeholders
        if text.contains("%") {
            return translateFormatString(text, to: to)
        }
        
        // For other strings, apply rule-based translation
        return ruleBasedTranslate(text, to: to)
    }
    
    private func translateFormatString(_ text: String, to locale: String) -> String {
        // Preserve format specifiers like %d, %@, etc.
        
        switch locale {
        case "tr":
            // Turkish-specific format string handling
            if text == "%d%% off" {
                return "%%%d indirim"
            }
        default:
            break
        }
        
        return text // Fallback - requires manual translation
    }
    
    private func ruleBasedTranslate(_ text: String, to locale: String) -> String {
        guard locale == "tr" else {
            return text // Only Turkish supported for now
        }
        
        // Simple rule-based translations for Turkish
        let lowercased = text.lowercased()
        
        let mappings: [String: String] = [
            "all subscriptions": "T√ºm abonelikler",
            "restore purchases": "Satƒ±n alƒ±mlarƒ± geri y√ºkle",
            "restore": "Geri y√ºkle",
            "purchases restored successfully!": "Satƒ±n alƒ±mlar ba≈üarƒ±yla geri y√ºklendi!",
            "terms and conditions": "≈ûartlar ve ko≈üullar",
            "terms": "≈ûartlar",
            "privacy policy": "Gizlilik politikasƒ±",
            "privacy": "Gizlilik",
            "annual": "Yƒ±llƒ±k",
            "monthly": "Aylƒ±k",
            "weekly": "Haftalƒ±k",
            "lifetime": "√ñm√ºr boyu",
            "6 month": "6 Ay",
            "3 month": "3 Ay",
            "2 month": "2 Ay"
        ]
        
        if let translation = mappings[lowercased] {
            // Preserve original capitalization pattern
            if text.first?.isUppercase == true {
                return translation.prefix(1).uppercased() + translation.dropFirst()
            }
            return translation
        }
        
        // Fallback: mark for manual translation
        return text + " [NEEDS_TRANSLATION]"
    }
    
    // MARK: - File I/O
    
    private func loadStrings(locale: String) -> [String: String]? {
        let path = "\(SyncConfig.resourcesPath)/\(locale).lproj/Localizable.strings"
        
        guard let content = try? String(contentsOfFile: path, encoding: .utf8) else {
            return nil
        }
        
        return parseStringsFile(content)
    }
    
    private func parseStringsFile(_ content: String) -> [String: String] {
        var result: [String: String] = [:]
        
        // Parse .strings format: "key" = "value";
        let pattern = #"^\s*"([^"]+)"\s*=\s*"(.*)"\s*;\s*$"#
        let regex = try! NSRegularExpression(pattern: pattern, options: .anchorsMatchLines)
        
        let nsString = content as NSString
        let matches = regex.matches(in: content, range: NSRange(location: 0, length: nsString.length))
        
        for match in matches {
            if match.numberOfRanges == 3 {
                let key = nsString.substring(with: match.range(at: 1))
                let value = nsString.substring(with: match.range(at: 2))
                result[key] = value
            }
        }
        
        return result
    }
    
    private func writeStrings(locale: String, strings: [String: String]) {
        let path = "\(SyncConfig.resourcesPath)/\(locale).lproj/Localizable.strings"
        
        var output = """
        /*
          Localizable.strings (\(locale.uppercased()))
          RevenueCatUI
        
          Copyright RevenueCat Inc. All Rights Reserved.
          Licensed under the MIT License.
          
          Auto-generated sections marked with [AUTO]
        */
        
        
        """
        
        // Sort keys for stable output
        let sortedKeys = strings.keys.sorted()
        
        for key in sortedKeys {
            let value = strings[key]!
            output += "\"\(key)\" = \"\(value)\";\n"
        }
        
        do {
            try output.write(toFile: path, atomically: true, encoding: .utf8)
            print("  ‚úÖ Wrote \(path)")
        } catch {
            errors.append("Failed to write \(path): \(error)")
        }
    }
    
    // MARK: - Results
    
    private func finalize() -> Int32 {
        print("\n" + String(repeating: "=", count: 60))
        
        if errors.isEmpty && modifications.isEmpty {
            print("‚úÖ All localizations are synchronized")
            print(String(repeating: "=", count: 60))
            return 0
        }
        
        if !errors.isEmpty {
            print("‚ùå ERRORS:")
            errors.forEach { print("  - \($0)") }
        }
        
        if !modifications.isEmpty {
            let total = modifications.values.reduce(0) { $0 + $1.count }
            print("\nüìä CHANGES:")
            print("  Total new translations: \(total)")
            
            for (locale, translations) in modifications {
                print("  \(locale): \(translations.count) new keys")
            }
            
            if mode == .check {
                print("\n‚ùå CI CHECK FAILED: Localizations are out of sync")
                print("Run: swift scripts/i18n_sync.swift --sync")
                print(String(repeating: "=", count: 60))
                return 1
            } else {
                print("\n‚úÖ Localizations synchronized")
            }
        }
        
        print(String(repeating: "=", count: 60))
        return errors.isEmpty ? 0 : 1
    }
}

// MARK: - Entry Point

let arguments = CommandLine.arguments
let mode: I18nSync.Mode

if arguments.contains("--check") {
    mode = .check
} else if arguments.contains("--sync") {
    mode = .sync
} else {
    print("Usage: swift scripts/i18n_sync.swift [--check|--sync]")
    print("")
    print("  --check  Check if translations are in sync (CI mode)")
    print("  --sync   Synchronize and auto-translate missing keys (Dev mode)")
    exit(1)
}

let sync = I18nSync(mode: mode)
exit(sync.run())
